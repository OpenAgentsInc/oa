
use crate::repo::postgres::PostgresPool;
use sqlx::migrate::MigrateDatabase;
use sqlx::postgres::Postgres;
use sqlx::Executor;
use std::str::FromStr;
use tracing::info;

pub async fn run_migrations(pool: &PostgresPool) -> Result<usize, sqlx::Error> {
    let mut conn = pool.acquire().await?;
    let migrations = vec![
        include_str!("../../migrations/20230101_init.sql"),
        include_str!("../../migrations/20230102_add_expires.sql"),
        include_str!("../../migrations/20230103_add_verification.sql"),
        include_str!("../../migrations/20230104_add_account.sql"),
        include_str!("../../migrations/20230105_add_invoice.sql"),
    ];

    let mut version = 0;
    for migration in migrations {
        version += 1;
        info!("Running migration v{}", version);
        conn.execute(migration).await?;
    }
    Ok(version)
}

pub async fn create_database(url: &str) -> Result<(), sqlx::Error> {
    let db_url = sqlx::postgres::PgConnectOptions::from_str(url)
        .unwrap()
        .database("postgres");
    let mut conn = sqlx::PgConnection::connect_with(&db_url).await?;
    let db_name = sqlx::postgres::PgConnectOptions::from_str(url)
        .unwrap()
        .get_database()
        .unwrap()
        .to_string();

    if !Postgres::database_exists(&url).await? {
        info!("Creating database {}", db_name);
        Postgres::create_database(&url).await?;
    }

    let query = format!("CREATE EXTENSION IF NOT EXISTS pg_trgm;");
    let _ = conn.execute(query.as_str()).await;

    Ok(())
}
